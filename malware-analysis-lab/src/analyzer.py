#!/usr/bin/env python3

import os
import sys
import hashlib
import magic
import pefile
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
import requests
from typing import Dict, List, Optional
import json

# Try to import yara, but make it optional
try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False

class MalwareAnalyzer:
    def __init__(self):
        self.console = Console()
        self.mime = magic.Magic(mime=True)
        self.vt_api_key = os.getenv('VT_API_KEY')  # Optional VirusTotal API key

        # Load YARA rules if available
        self.yara_rules = None
        if YARA_AVAILABLE:
            script_path = os.path.dirname(os.path.abspath(__file__))
            project_root = os.path.dirname(script_path)
            self.rules_path = os.path.join(project_root, 'data', 'rules.yar')
            try:
                self.yara_rules = yara.compile(filepath=self.rules_path)
            except Exception as e:
                self.console.print(f"[yellow]Warning: Failed to load YARA rules: {str(e)}[/yellow]")

    def calculate_hashes(self, file_path: str) -> Dict[str, str]:
        """Calculate MD5, SHA1, and SHA256 hashes of the file."""
        hashes = {}
        with open(file_path, 'rb') as f:
            data = f.read()
            hashes['md5'] = hashlib.md5(data).hexdigest()
            hashes['sha1'] = hashlib.sha1(data).hexdigest()
            hashes['sha256'] = hashlib.sha256(data).hexdigest()
        return hashes

    def get_file_info(self, file_path: str) -> Dict:
        """Get basic file information."""
        file_info = {
            'size': os.path.getsize(file_path),
            'type': self.mime.from_file(file_path),
            'hashes': self.calculate_hashes(file_path)
        }
        return file_info

    def analyze_pe(self, file_path: str) -> Optional[Dict]:
        """Analyze PE file headers and sections."""
        try:
            pe = pefile.PE(file_path)
            pe_info = {
                'machine_type': hex(pe.FILE_HEADER.Machine),
                'timestamp': pe.FILE_HEADER.TimeDateStamp,
                'sections': []
            }

            for section in pe.sections:
                pe_info['sections'].append({
                    'name': section.Name.decode().rstrip('\x00'),
                    'virtual_address': hex(section.VirtualAddress),
                    'virtual_size': section.Misc_VirtualSize,
                    'raw_size': section.SizeOfRawData,
                    'entropy': section.get_entropy()
                })

            return pe_info
        except Exception:
            return None

    def extract_strings(self, file_path: str, min_length: int = 4) -> List[str]:
        """Extract printable strings from the file."""
        strings = []
        with open(file_path, 'rb') as f:
            data = f.read()
            current_string = ""
            for byte in data:
                if 32 <= byte <= 126:  # Printable ASCII
                    current_string += chr(byte)
                else:
                    if len(current_string) >= min_length:
                        strings.append(current_string)
                    current_string = ""
        return strings

    def check_virustotal(self, file_hash: str) -> Optional[Dict]:
        """Check file hash against VirusTotal (if API key is available)."""
        if not self.vt_api_key:
            return None

        url = f'https://www.virustotal.com/vtapi/v2/file/report'
        params = {'apikey': self.vt_api_key, 'resource': file_hash}

        try:
            response = requests.get(url, params=params)
            if response.status_code == 200:
                return response.json()
        except requests.RequestException:
            pass
        return None

    def scan_with_yara(self, file_path: str) -> List[Dict]:
        """Scan file with YARA rules."""
        if not YARA_AVAILABLE or not self.yara_rules:
            return []

        try:
            matches = self.yara_rules.match(file_path)
            return [
                {
                    'rule': match.rule,
                    'meta': match.meta,
                    'strings': match.strings
                }
                for match in matches
            ]
        except Exception as e:
            self.console.print(f"[yellow]Warning: YARA scan failed: {str(e)}[/yellow]")
            return []

    def search_for_suspicious_patterns(self, file_path: str) -> List[Dict]:
        """Search for suspicious patterns manually if YARA is not available."""
        if YARA_AVAILABLE and self.yara_rules:
            return []  # Will use YARA instead

        suspicious_patterns = {
            "cmd.exe": "Command shell",
            "powershell.exe": "PowerShell",
            "net user": "User account manipulation",
            "wmic": "WMI command",
            "system32": "System directory access",
            "CreateRemoteThread": "Remote thread creation",
            "VirtualAlloc": "Memory allocation",
            "WriteProcessMemory": "Process memory manipulation",
            "ShellExecute": "Shell execution",
            "WinExec": "Windows execution",
            "CreateProcess": "Process creation",
            "IsDebuggerPresent": "Anti-debugging technique",
            "CheckRemoteDebuggerPresent": "Anti-debugging technique"
        }

        results = []
        content = ""
        with open(file_path, 'rb') as f:
            try:
                content = f.read().decode('utf-8', errors='ignore')
            except Exception:
                return results

        for pattern, description in suspicious_patterns.items():
            if pattern in content:
                results.append({
                    'pattern': pattern,
                    'description': description
                })

        return results

    def analyze_file(self, file_path: str) -> None:
        """Perform comprehensive analysis of the file."""
        if not os.path.exists(file_path):
            self.console.print(f"[red]Error: File {file_path} does not exist[/red]")
            return

        # Basic file information
        file_info = self.get_file_info(file_path)

        # Create results table
        table = Table(title="File Analysis Results")
        table.add_column("Property", style="cyan")
        table.add_column("Value", style="green")

        # Add basic information
        table.add_row("File Size", f"{file_info['size']} bytes")
        table.add_row("File Type", file_info['type'])
        table.add_row("MD5", file_info['hashes']['md5'])
        table.add_row("SHA1", file_info['hashes']['sha1'])
        table.add_row("SHA256", file_info['hashes']['sha256'])

        # PE Analysis
        pe_info = self.analyze_pe(file_path)
        if pe_info:
            table.add_row("File Format", "PE (Portable Executable)")
            table.add_row("Machine Type", pe_info['machine_type'])
            table.add_row("Compilation Timestamp", str(pe_info['timestamp']))

            # Add section information
            sections_table = Table(title="PE Sections")
            sections_table.add_column("Name")
            sections_table.add_column("Virtual Address")
            sections_table.add_column("Size")
            sections_table.add_column("Entropy")

            for section in pe_info['sections']:
                sections_table.add_row(
                    section['name'],
                    section['virtual_address'],
                    str(section['virtual_size']),
                    f"{section['entropy']:.2f}"
                )

            self.console.print(sections_table)

        # Display results
        self.console.print(table)

        # YARA analysis or pattern matching
        if YARA_AVAILABLE and self.yara_rules:
            # YARA analysis if available
            yara_matches = self.scan_with_yara(file_path)
            if yara_matches:
                yara_table = Table(title="YARA Rule Matches")
                yara_table.add_column("Rule", style="red")
                yara_table.add_column("Description", style="yellow")

                for match in yara_matches:
                    yara_table.add_row(
                        match['rule'],
                        match['meta'].get('description', 'No description')
                    )

                self.console.print(yara_table)
                self.console.print("[bold red]⚠️ Warning: Suspicious patterns detected![/bold red]")
            else:
                self.console.print("[green]✓ No YARA rule matches found[/green]")
        else:
            # Fallback pattern matching if YARA is not available
            self.console.print("[yellow]Note: YARA is not available. Using basic pattern matching instead.[/yellow]")
            pattern_matches = self.search_for_suspicious_patterns(file_path)

            if pattern_matches:
                pattern_table = Table(title="Suspicious Pattern Matches")
                pattern_table.add_column("Pattern", style="red")
                pattern_table.add_column("Description", style="yellow")

                for match in pattern_matches:
                    pattern_table.add_row(
                        match['pattern'],
                        match['description']
                    )

                self.console.print(pattern_table)
                self.console.print("[bold red]⚠️ Warning: Suspicious patterns detected![/bold red]")
            else:
                self.console.print("[green]✓ No suspicious patterns found[/green]")

        # Extract and display strings
        strings = self.extract_strings(file_path)
        if strings:
            self.console.print(Panel(
                "\n".join(strings[:20]),  # Show first 20 strings
                title="Extracted Strings (First 20)",
                expand=False
            ))

def main():
    if len(sys.argv) != 2:
        print("Usage: python analyzer.py <file_path>")
        sys.exit(1)

    analyzer = MalwareAnalyzer()
    analyzer.analyze_file(sys.argv[1])

if __name__ == "__main__":
    main()
